#!/bin/bash

# Set the Consul HTTP API address
#CONSUL_HTTP_ADDR="http://localhost:8500"
## Set your ACL token here
#CONSUL_HTTP_TOKEN="your-acl-token"
# set -e

eval "$(cat /etc/profile.d/consul.sh)"

# Function to create a namespace
function create_namespace() {
  local namespace_name=$1
  local payload="{\"Name\": \"${namespace_name}\"}"

  curl -s -X PUT -H "X-Consul-Token: $CONSUL_HTTP_TOKEN" \
       -H "Content-Type: application/json" \
       --data "${payload}" \
       "${CONSUL_HTTP_ADDR}/v1/namespace"
}

# Function to create a fake service with a check and random KV for each namespace
function create_services() {
  local namespace=$1
  local datacenter
  datacenter="$(curl -s -H "X-Consul-Token: $CONSUL_HTTP_TOKEN" "$CONSUL_HTTP_ADDR"/v1/agent/self | jq -r '.Config.Datacenter')"
  # Register a fake service
  service_payload="$(cat <<EOF
{
  "Node": "fake-node",
  "Address": "127.0.0.1",
  "Service": {
    "ID": "fake-service",
    "Service": "fake-service",
    "Tags": [
      "$datacenter"
    ],
    "Address": "127.0.0.1",
    "Port": 8080
  },
  "Checks": [
    {
      "CheckID": "service:fake-service",
      "Name": "Fake service check",
      "Notes": "Generated by script",
      "Status": "passing",
      "ServiceID": "fake-service"
    }
  ]
}
EOF
)"

  curl --silent --no-progress-meter -X PUT -H "X-Consul-Token: $CONSUL_HTTP_TOKEN" \
       -d "$service_payload" "${CONSUL_HTTP_ADDR}/v1/catalog/register?ns=${namespace}"
}

function create_kv() {
  local namespace=$1
  # Create random KV pairs
  for i in {1..5}; do
    random_key="key_$i"
    random_value="value_$RANDOM"
    response="$(curl --silent --no-progress-meter -X PUT -H "X-Consul-Token: $CONSUL_HTTP_TOKEN" \
      -d "$random_value" "${CONSUL_HTTP_ADDR}/v1/kv/${random_key}?ns=${namespace}")"
  done
  echo "$response"
}

function create_acl_resources() {
  local namespace=$1
  local ca_cert_blob
  local response
  local fake_jwt
  fake_jwt="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJmYWtlLWlzc3VlciIsInN1YiI6ImZha2Utc3ViamVjdCIsIm5hbWUiOiJKb2huIERvZSIsImlhdCI6MTUxNjIzOTAyMn0.abc123abc123abc123abc123abc123ab"
  # Read the contents of the PEM file
  if [ -f "$CONSUL_CACERT" ]; then
    ca_cert_blob=$(awk 'NF {sub(/\r/, ""); printf "%s\\n",$0;}' < "$CONSUL_CACERT")
  else
    echo "The certificate file $PEM_FILE does not exist."
    return
  fi

# Create the JSON payload using jq
auth_method_payload=$(cat <<EOF
{
  "Name": "example-auth-method",
  "Namespace": "${namespace}",
  "Type": "kubernetes",
  "Description": "Example Kubernetes auth method",
  "Config": {
    "Host": "https://acme.com",
    "CACert": "${ca_cert_blob}",
    "ServiceAccountJWT": "${fake_jwt}"
  }
}
EOF
)
  response="$(curl -X PUT -H "X-Consul-Token: $CONSUL_HTTP_TOKEN" \
    --write-out "%{http_code}" --silent --output /dev/null \
    -d "$auth_method_payload" "${CONSUL_HTTP_ADDR}/v1/acl/auth-method?ns=${namespace}")"

  status_code=$(tail -n1 <<< "$response")
  if [[ "$status_code" -ne 200 && "$status_code" -ne 201 ]]; then
    echo "Failed to create ACL auth method in namespace $namespace with status code: $status_code"
  else
    echo "Successfully created ACL auth method in namespace $namespace"
  fi
# Create ACL Binding Rule
binding_rule_payload=$(cat <<EOF
{
  "Description": "Bind all service accounts with a specific prefix",
  "AuthMethod": "example-auth-method",
  "Selector": "serviceaccount.namespace!=default",
  "BindType": "service",
  "BindName": "fake-service-name"
}
EOF
)
  response=$(curl -X PUT -H "X-Consul-Token: $CONSUL_HTTP_TOKEN" \
    --write-out "%{http_code}" --silent --output /dev/null \
    -d "$binding_rule_payload" "${CONSUL_HTTP_ADDR}/v1/acl/binding-rule?ns=${namespace}")

  status_code=$(tail -n1 <<< "$response")
  if [[ "$status_code" -ne 200 && "$status_code" -ne 201 ]]; then
    echo "Failed to create ACL binding rule in namespace $namespace with status code: $status_code"
  else
    echo "Successfully created ACL binding rule in namespace $namespace"
  fi
# Create ACL Policy
policy_payload=$(cat <<EOF
{
  "Name": "cross-namespace-policy",
  "Description": "Provides read access across all services and nodes",
  "Rules": "partition \\"default\\" { namespace \\"${namespace}\\" { service_prefix \\"\\" { policy = \\"read\\" } node_prefix \\"\\" { policy = \\"read\\" } } }"
}
EOF
)

  response="$(curl -X PUT -H "X-Consul-Token: $CONSUL_HTTP_TOKEN" \
    --write-out "%{http_code}" --silent --output /dev/null \
    -d "$policy_payload" "${CONSUL_HTTP_ADDR}/v1/acl/policy?ns=${namespace}")"

  status_code=$(tail -n1 <<< "$response")
  if [[ "$status_code" -ne 200 && "$status_code" -ne 201 ]]; then
    echo "Failed to create ACL policy in namespace $namespace with status code: $status_code"
  else
    echo "Successfully created ACL policy in namespace $namespace"
  fi

# Create ACL Role
role_payload=$(cat <<EOF
{
  "Name": "example-role",
  "Namespace": "${namespace}",
  "Description": "Example Role",
  "Policies": [{"Name": "cross-namespace-policy"}]
}
EOF
)
  response="$(curl -X PUT -H "X-Consul-Token: $CONSUL_HTTP_TOKEN" \
    --write-out "%{http_code}" --silent --output /dev/null \
    -d "$role_payload" "${CONSUL_HTTP_ADDR}/v1/acl/role?ns=${namespace}")"

  status_code=$(tail -n1 <<< "$response")
  if [[ "$status_code" -ne 200 && "$status_code" -ne 201 ]]; then
    echo "Failed to create ACL role in namespace $namespace with status code: $status_code"
  else
    echo "Successfully created ACL role in namespace $namespace"
  fi

# Create ACL Token
token_payload=$(cat <<EOF
{
  "Description": "Example token",
  "Namespace": "${namespace}",
  "Policies": [{"Name": "cross-namespace-policy"}],
  "Local": true
}
EOF
)
  response="$(curl -X PUT -H "X-Consul-Token: $CONSUL_HTTP_TOKEN" \
    --write-out "%{http_code}" --silent --output /dev/null \
    -d "$token_payload" "${CONSUL_HTTP_ADDR}/v1/acl/token?ns=${namespace}")"

  status_code=$(tail -n1 <<< "$response")
  if [[ "$status_code" -ne 200 && "$status_code" -ne 201 ]]; then
    echo "Failed to create ACL token in namespace $namespace with status code: $status_code"
  else
    echo "Successfully created ACL token in namespace $namespace"
  fi
  echo "ACL resources created in namespace ${namespace}"
}

# Function to delete a namespace
function delete_namespace() {
  local namespace_name=$1

  curl -X DELETE -H "X-Consul-Token: $CONSUL_HTTP_TOKEN" \
    --write-out "%{http_code}" --silent --output /dev/null \
    "${CONSUL_HTTP_ADDR}/v1/namespace/${namespace_name}"
}

# Apply configuration function
function apply_config_in_namespaces() {
  local namespace=$1
  local config_type=$2
  local config_data=""

  # Case statement for different configuration types
  case "$config_type" in
    "service-defaults")
      config_data="$(cat <<EOF
{
  "Kind": "service-defaults",
  "Name": "fake-service",
  "Namespace": "${namespace}",
  "Protocol": "http"
}
EOF
)"
      ;;
    "ingress-gateway")
      config_data="$(cat <<EOF
{
  "Kind": "ingress-gateway",
  "Name": "ingress-gateway",
  "Namespace": "default",
  "Listeners": [
    {
      "Port": 8888,
      "Protocol": "tcp",
      "Services": [
        {
          "Name": "fake-service",
          "Namespace": "default"
        }
      ]
    },
    {
      "Port": 8181,
      "Protocol": "http",
      "Services": [
        {
          "Name": "*",
          "Namespace": "default"
        }
      ]
    },
    {
      "Port": 9191,
      "Protocol": "http2",
      "Services": [
        {
          "Name": "*",
          "Namespace": "default"
        }
      ]
    }
  ]
}
EOF
)"
      ;;
    "service-router")
      config_data="$(cat <<EOF
{
  "Kind": "service-router",
  "Name": "frontend-router",
  "Namespace": "${namespace}",
  "Routes": {
    "Match": {
      "HTTP": {
        "PathPrefix": "/"
      },
      "HTTP": {
        "Methods": ["GET", "POST", "PUT"]
      }
    }
  }
}
EOF
)"
      ;;
    "service-splitter")
      config_data="$(cat <<EOF
{
  "Kind" : "service-splitter",
  "Name" : "frontend-splitter",
  "Namespace" : "${namespace}",
  "Splits" : [
    {
      "Weight" : 100,
      "Service" : "*",
      "Namespace" : "default"
    },
    {
      "Weight" : 0,
      "Service" : "fake-service",
      "Namespace" : "namespace-200"
    }
  ]
}
EOF
)"
    ;;
    *)
      echo "Unknown config type: $config_type"
      return 1
      ;;
  esac
  # Apply the configuration using the Consul API
  response=$(curl --silent --request PUT \
    --header "X-Consul-Token: ${CONSUL_HTTP_TOKEN}" \
    --header "Content-Type: application/json" \
    --data "${config_data}" \
    "${CONSUL_HTTP_ADDR}/v1/config?ns=${namespace}")

  # Check response
  if [ "$response" = true ]; then
    echo "Configuration for type '${config_type}' applied in namespace '${namespace}'."
  else
    echo "Failed to apply configuration for type '${config_type}' in namespace '${namespace}'."
    echo "Response: $response"
  fi
}

# Check for command and number of namespaces
if [ -z "$1" ] || [ -z "$2" ]; then
  echo "Usage: $0 [create|delete|create-services|create-kv-entries|create-acl-resources|create-config-entries] <number_of_namespaces>"
  exit 0
fi

command="$1"
number_of_namespaces="$2"
config_type="$3"

# Main loop to create or delete namespaces
for ((i=1; i<=number_of_namespaces; i++)); do
  namespace_name="namespace-$i"
  case "$command" in
    create)
      echo "Creating namespace: $namespace_name"
      response=$(create_namespace "$namespace_name")
      ;;
    create-services)
      echo "Creating service in $namespace_name"
      response=$(create_services "$namespace_name")
    ;;
    create-kv-entries)
      echo "Creating kv entry in $namespace_name"
      response=$(create_kv "$namespace_name")
    ;;
    create-acl-resources)
      echo "Creating acl resources in $namespace_name"
      response=$(create_acl_resources "$namespace_name")
    ;;
    create-config-entries)
      echo "Creating config entries in $namespace_name"
      response=$(apply_config_in_namespaces "$namespace_name" "$config_type")
    ;;
    delete)
      echo "Deleting namespace: $namespace_name"
      response=$(delete_namespace "$namespace_name")
      ;;
    *)
      echo "Unknown command: $command"
      echo "Usage: $0 [create|delete] <number_of_namespaces>"
      return
  esac
  echo "Response: $response"
done

echo "Finished $command $number_of_namespaces namespaces."
